# 15-puzzle-Solver
Оптимально решает (3x3) головоломку, приближает решение (4x4), (5x5), (6x6), (7x7). Для досок размера > 5 может работать долго.

Помещаем 2 файла в одну папку, запускаем main.py

Способ решения: представление состояний доски в виде графа, где точки - возможные поля, ребра - ходы.

Используется A* алгоритм для нахождения кратчайшего пути по этим точкам.

Для доски 3x3 в качестве эвристической функции используется сумма Манхеттенских расстояний от клеток до мест, где они должны стоять. За пустую клетку не штрафуем. Это расстояние не превышает фактическое расстояние, поэтому алгоритм находит оптимальное решение.

Для доски 4x4 предыдущий метод приводит к большому времени ожидания. Поэтому используется другая функция.

Для каждой клетки считается Манхеттенское расстояние до позиции, на которой она должна стоять. Этому расстоянию ставится в соответствие штраф, заданный массивом:
```python
penalty_dist = [0, 2, 4, 6, 8, 10, 12]
```
penalty_dist[S] = штраф за расстояние S

Далее штраф умножается на корректирующий коэффициент в зависимости от номера, указанного на клетке:
```python
scores = [1, 1, 1, 1,
          1, 1, 1, 1,
          1, 1, 1, 1,
          1, 1, 1, 0]
```
Т. е. за пустую клетку не штрафуем, а за остальные штрафуем одинаково.

Для досок размера >= 5 используются следующие параметры:

```python
scores = [1] * (SIZE * SIZE)
scores[-1] = 0
penalty_dist = [i * 10 for i in range(2 * SIZE - 1)]
```
Т. е. за все клетки штрафуем одинаково. За расстояние S штрафуем 10 * S.

Начиная с размера > 5 алгоритм находит хорошее почти решение - остаются 1 или 2 пары клеток, которые стоят рядом, и которые нужно поменять, на алгоритм этого не может сделать из-за того, что не хочет получить штрафы за перемещение клеток на пути к тем, которые нужно поменять
